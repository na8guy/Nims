c<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Nims Climb</title>
    <script src="https://telegram.org/js/telegram-web-app.js" onload="onWebAppScriptLoaded()"></script> <style>
        /* ... (Keep the CSS from the previous full index.html example) ... */
        /* Ensure old HTML button area is hidden if elements still exist */
        #start-controls { display: none !important; } /* Hide old controls */
        /* Adjust styles as needed for the new layout */
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; margin: 0; padding: 15px; background-color: var(--tg-theme-bg-color, #f0f0f0); color: var(--tg-theme-text-color, #333); display: flex; flex-direction: column; min-height: 100vh; box-sizing: border-box;}
        .container { width: 100%; max-width: 600px; margin: 0 auto; background: var(--tg-theme-secondary-bg-color, white); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); flex-grow: 1; display: flex; flex-direction: column; box-sizing: border-box;}
        h1 { text-align: center; color: var(--tg-theme-link-color, #007bff); margin-top: 0; margin-bottom: 15px; font-weight: 600; }
        .balance { margin-bottom: 20px; background-color: rgba(0, 123, 255, 0.05); padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(0, 123, 255, 0.1);}
        .balance p { margin: 5px 0; font-size: 16px; display: flex; justify-content: space-between; }
        .balance span { font-weight: 600; color: var(--tg-theme-link-color, #007bff); }
        .controls, #game-interface { display: flex; flex-direction: column; gap: 12px; }
        label { font-size: 14px; color: var(--tg-theme-hint-color, #6c757d); margin-bottom: -5px;}
        select, input[type="number"] { padding: 12px; font-size: 16px; border: 1px solid var(--tg-theme-hint-color, #ccc); border-radius: 8px; background-color: var(--tg-theme-bg-color, #fff); color: var(--tg-theme-text-color, #333); width: 100%; box-sizing: border-box;}
        #game-interface { display: none; margin-top: 20px; align-items: center; }
        #multiplier-display { font-size: 28px; font-weight: bold; color: var(--tg-theme-link-color, #007bff); text-align: center; margin-bottom: 15px; background: #eef; padding: 10px; border-radius: 8px;}
        #status { margin-top: 15px; font-weight: 500; text-align: center; font-size: 15px; }
        .error { color: var(--tg-theme-destructive-text-color, red); font-weight: bold;}
        #log-panel { margin-top: 20px; padding: 10px; background-color: rgba(0,0,0,0.03); border: 1px solid var(--tg-theme-hint-color, #ddd); border-radius: 8px; max-height: 100px; overflow-y: auto; font-size: 11px; text-align: left; line-height: 1.4; font-family: monospace; color: var(--tg-theme-hint-color); }
        .log-entry { margin: 2px 0; word-break: break-all; }
        .log-info { color: var(--tg-theme-text-color); }
        .log-warn { color: #ff8c00; }
        .log-error { color: var(--tg-theme-destructive-text-color, #ff0000); font-weight: bold;}
        /* Controls needed for stake input */
        #stake-controls { display: flex; flex-direction: column; gap: 12px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§— Nims Climb</h1>
        <div class="balance">
            <p>BNB Balance: <span id="bnb-balance">0.0000</span></p>
            <p>NIMS Balance: <span id="nims-balance">0.0000</span></p>
        </div>

        <div id="stake-controls">
             <label for="token-select">Currency:</label>
             <select id="token-select">
                 <option value="BNB">BNB</option>
                 <option value="NIMS">NIMS</option>
             </select>
             <label for="stake-input">Stake Amount:</label>
             <input type="number" id="stake-input" placeholder="Enter stake (0.1 - 10)" step="0.1" min="0.1" max="10" value="0.1">
             </div>

        <div id="game-interface">
            <p id="multiplier-display">Multiplier: <span id="multiplier">1.00x</span></p>
            </div>

        <p id="status">Initializing...</p>
        <div id="log-panel"></div>
    </div>

  <script>
    // --- Global Variables ---
    let WebApp;
    let isInitialized = false;
    let isGameActive = false;
    let currentStake = 0;
    let currentToken = '';
    let currentSessionId = null;
    let multiplier = 1.0;
    let gameInterval; // Can be interval ID or animation frame ID
    let animationFrameId = null; // Specifically for requestAnimationFrame

    const crashProbability = 0.03;
    const intervalTime = 400; // Target interval for multiplier increase (ms)
    const multiplierIncrement = 0.05;

    // --- DOM Element References ---
    const statusEl = document.getElementById('status');
    const logPanel = document.getElementById('log-panel');
    const stakeControls = document.getElementById('stake-controls'); // New ID for stake inputs area
    const gameInterface = document.getElementById('game-interface');
    const multiplierEl = document.getElementById('multiplier');
    const bnbBalanceEl = document.getElementById('bnb-balance');
    const nimsBalanceEl = document.getElementById('nims-balance');
    const stakeInput = document.getElementById('stake-input');
    const tokenSelect = document.getElementById('token-select');

    // --- Logging and Status ---
    function logToUI(level, message) { /* ... keep existing logToUI ... */ }
    function updateStatus(message, isError = false) { /* ... keep existing updateStatus ... */ }

    // --- WebApp Initialization ---
    function onWebAppScriptLoaded() {
        // This is called by the script tag's onload attribute
        logToUI('INFO', 'Telegram WebApp SDK script loaded via onload');
        initializeWebApp(); // Initialize immediately after script loads
    }

   function initializeWebApp() {
        if (isInitialized) return;
        logToUI('INFO', 'Attempting to initialize Telegram WebApp...');

        logToUI('DEBUG', `Checking window.Telegram: ${typeof window.Telegram}`);
        logToUI('DEBUG', `Checking window.Telegram.WebApp: ${typeof window.Telegram?.WebApp}`);
        WebApp = window.Telegram?.WebApp;

        if (!WebApp) { logToUI('ERROR', 'window.Telegram.WebApp object is missing!'); updateStatus('Error: SDK Missing.', true); return; }
        logToUI('DEBUG', `Checking WebApp.initData: ${!!WebApp.initData}`);
        if (!WebApp.initData) { logToUI('ERROR', 'WebApp.initData is missing!'); updateStatus('Error: Init Data Missing.', true); return; }

        /*try {
            logToUI('INFO', `WebApp Raw initData: ${WebApp.initData.substring(0, 60)}...`);
            WebApp.ready(); // Inform Telegram UI is ready
            logToUI('INFO', 'WebApp.ready() called.');
            WebApp.expand(); // Expand the view

            // Apply theme
            document.body.style.backgroundColor = WebApp.themeParams.bg_color || '#f0f0f0';
            document.body.style.color = WebApp.themeParams.text_color || '#333';

            isInitialized = true;
            logToUI('INFO', 'WebApp initialized successfully.');
            updateStatus('Loading your data...');

            loadGameDataFromUrl(); // Load initial balance/state AFTER init
            setupMainButton(); // Setup the Main Button logic

        } catch (e) {
            logToUI('ERROR', `WebApp initialization failed: ${e.message}`);
            updateStatus('Error initializing WebApp interface.', true);
        }*/
        try {
        logToUI('DEBUG', 'Calling WebApp.ready()...');
        WebApp.ready();
        logToUI('DEBUG', 'Called WebApp.ready(). Calling expand()...');
        WebApp.expand();
        logToUI('DEBUG', 'Called expand(). Setting up theme...');
        // ... (theme setup) ...
        logToUI('DEBUG', 'Theme set. Calling loadGameDataFromUrl()...');
        loadGameDataFromUrl();
        logToUI('DEBUG', 'Called loadGameDataFromUrl(). Calling setupMainButton()...');
        setupMainButton();
        logToUI('DEBUG', 'Called setupMainButton(). Initialization complete.');
    } catch (e) {  logToUI('ERROR', `WebApp initialization failed: ${e.message}`);
            updateStatus('Error initializing WebApp interface.', true); }
    }

    // --- Data Handling ---
    function loadGameDataFromUrl() {
        // ... (Keep existing loadGameDataFromUrl - it should be fine) ...
         const urlParams = new URLSearchParams(window.location.search);
         const dataParam = urlParams.get('data');
         if (!dataParam) {
             logToUI('WARN', 'No initial data parameter found in URL.');
             updateStatus('Ready to climb!');
             resetToStartScreen(); // Ensure UI is correct state
             return;
         }
        try {
        logToUI('DEBUG', 'Decoding data parameter...');
        const decodedData = decodeURIComponent(dataParam);
        logToUI('DEBUG', 'Parsing JSON...');
        const gameData = JSON.parse(decodedData);
        logToUI('DEBUG', 'Parsed gameData: ' + JSON.stringify(gameData)); // Log the actual data
        logToUI('DEBUG', 'Updating BNB balance display...');
        bnbBalanceEl.textContent = parseFloat(gameData.bnb_balance || 0).toFixed(4);
        logToUI('DEBUG', 'Updating NIMS balance display...');
        nimsBalanceEl.textContent = parseFloat(gameData.nims_balance || 0).toFixed(4);
        logToUI('DEBUG', 'Balance displays updated.');

             if (gameData.game_started && gameData.game_started.session_id) {
                 logToUI('INFO', `Found active game session in URL data: session_id=${gameData.game_started.session_id}`);
                 startClimbing(gameData.game_started); // Start/resume game state
             } else {
                  logToUI('INFO', 'No active game session found in URL data.');
                  resetToStartScreen();
                  updateStatus('Ready to climb!');
             }
         } catch (e) {
             logToUI('ERROR', `Failed to parse game data from URL: ${e.message}`);
             updateStatus('Error loading data from Telegram.', true);
             resetToStartScreen();
         }
    }

    function sendBotData(data) {
        // ... (Keep existing sendBotData - it should be fine) ...
         if (!WebApp || !isInitialized) { logToUI('ERROR', 'WebApp not initialized, cannot send data.'); updateStatus('Error: Cannot communicate.', true); return false; }
         try {
             const dataString = JSON.stringify(data);
             logToUI('INFO', `Sending data to bot: ${dataString}`);
             WebApp.sendData(dataString);
             logToUI('DEBUG', 'WebApp.sendData called.');
             return true;
         } catch (e) {
             logToUI('ERROR', `Failed to send data via WebApp.sendData: ${e.message}`);
             updateStatus('Communication Error.', true);
             return false;
         }
    }

    // --- Main Button Logic ---
    function setupMainButton() {
        // Configures the Main Button text and action based on game state
        logToUI('DEBUG', `Setting up Main Button. Game active: ${isGameActive}`);
        if (!WebApp || !WebApp.MainButton) { logToUI('ERROR', 'WebApp or MainButton not ready for setup.'); return; }

        WebApp.MainButton.offClick(mainButtonClickHandler); // Remove previous listener

        if (isGameActive) {
            // Game is running - button should be "Cash Out"
            WebApp.MainButton
                .setText('Cash Out') // Keep text simple or add multiplier dynamically if needed
                .setColor(WebApp.themeParams.button_color || '#007bff') // Standard button color
                .enable()
                .show();
        } else {
            // Game not running - button should be "Start Climbing"
            WebApp.MainButton
                .setText('Start Climbing')
                .setColor('#28a745') // Use a distinct "start" color (e.g., green)
                .enable()
                .show();
        }
        WebApp.MainButton.onClick(mainButtonClickHandler); // Add the listener
        WebApp.MainButton.hideProgress(); // Ensure progress indicator is hidden initially
    }

    function mainButtonClickHandler() {
        // Single handler decides action based on game state
        logToUI('DEBUG', 'Main Button was clicked.');
        if (isGameActive) {
            handleCashoutViaMainButton();
        } else {
            handleStartGameViaMainButton();
        }
    }

    function handleStartGameViaMainButton() {
        logToUI('INFO', 'Attempting to start game via Main Button...');
        const stake = parseFloat(stakeInput.value);
        const token = tokenSelect.value;

        // --- Validation ---
        if (!token || (token !== 'BNB' && token !== 'NIMS')) { updateStatus('Select BNB or NIMS.', true); return; }
        const minStake = 0.1, maxStake = 10.0;
        if (isNaN(stake) || stake < minStake || stake > maxStake) { updateStatus(`Stake must be ${minStake} - ${maxStake} ${token}.`, true); stakeInput.focus(); return; }
        const balance = token === 'BNB' ? parseFloat(bnbBalanceEl.textContent) : parseFloat(nimsBalanceEl.textContent);
        if (stake > balance) { updateStatus(`Insufficient ${token}: ${balance.toFixed(4)} avail.`, true); return; }

        const dataToSend = { action: 'start_game', token: token, stake: stake.toString() };

        WebApp.MainButton.showProgress(false); // Show indeterminate loading
        WebApp.MainButton.disable();
        updateStatus('Starting game...');

        if (!sendBotData(dataToSend)) {
            // If sending failed immediately
            WebApp.MainButton.hideProgress();
            WebApp.MainButton.enable();
            updateStatus('Failed to send start request.', true);
        }
        // If send succeeded, we wait for backend to potentially trigger startClimbing via URL reload
        // OR we could optimistically start the animation - requires careful state management
    }

    function handleCashoutViaMainButton() {
        logToUI('INFO', 'Attempting to cash out via Main Button...');
        if (!isGameActive || !currentSessionId) { logToUI('WARN', 'Cashout clicked but game/session not active.'); return; }

        const finalMultiplier = multiplier;
        stopGame(); // Stop animation, reset variables locally first

        const dataToSend = {
            action: 'cashout', session_id: currentSessionId,
            stake: currentStake, multiplier: finalMultiplier, token: currentToken
        };

        WebApp.MainButton.showProgress(false);
        WebApp.MainButton.disable();
        updateStatus('Cashing out...');

        if (!sendBotData(dataToSend)) {
             WebApp.MainButton.hideProgress();
             // Button state should be reset via stopGame -> resetToStartScreen -> setupMainButton
             updateStatus('Cashout failed to send.', true);
        }
        // Backend will confirm cashout via message. UI is already reset by stopGame.
    }

    // --- Game Logic ---
    function startClimbing(gameData) {
        if (isGameActive) { logToUI('WARN', `startClimbing called but game already active.`); return; }
        if (!gameData || !gameData.session_id) { logToUI('ERROR', 'Invalid game data for startClimbing.'); resetToStartScreen(); return; }

        isGameActive = true;
        currentStake = parseFloat(gameData.stake);
        currentToken = gameData.token;
        currentSessionId = gameData.session_id;
        multiplier = 1.0; // Reset multiplier for new game

        logToUI('INFO', `Starting climb animation: session ${currentSessionId}, Stake: ${currentStake} ${currentToken}`);

        stakeControls.style.display = 'none'; // Hide stake controls
        gameInterface.style.display = 'flex';
        multiplierEl.textContent = `${multiplier.toFixed(2)}x`;
        updateStatus(`Climbing! Current stake: ${currentStake} ${currentToken}`);

        setupMainButton(); // Update Main Button to "Cash Out" mode
        WebApp.enableClosingConfirmation(); // Prevent accidental close during game

        // --- Animation Loop ---
        let lastFrameTime = performance.now();
        let timeAccumulator = 0;
        if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous frame

        function gameLoop(currentTime) {
            if (!isGameActive) return; // Stop if game ended elsewhere

            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            timeAccumulator += deltaTime;

            while (timeAccumulator >= intervalTime) {
                multiplier += multiplierIncrement;
                multiplierEl.textContent = `${multiplier.toFixed(2)}x`; // Update display
                timeAccumulator -= intervalTime;

                // Crash check
                if (Math.random() < crashProbability) {
                    logToUI('WARN', `Crash detected visually at ${multiplier.toFixed(2)}x!`);
                    handleCrash(); // Handle crash: send data, stop loop
                    return; // Exit loop
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop); // Continue loop
        }
        animationFrameId = requestAnimationFrame(gameLoop); // Start loop
    }

    function handleCrash() {
         const crashedMultiplier = multiplier;
         stopGame(); // Stop animation, reset variables locally FIRST

         const dataToSend = {
             action: 'lost', session_id: currentSessionId,
             stake: currentStake, token: currentToken,
             multiplier_at_crash: crashedMultiplier
         };

         // Don't need to disable MainButton here, stopGame->resetToStartScreen handles it
         updateStatus(`ðŸ’¥ Crashed at ${crashedMultiplier.toFixed(2)}x! Game Over.`, true);

         if(!sendBotData(dataToSend)) {
             updateStatus('ðŸ’¥ Crashed! Failed to notify server.', true);
         } else {
             logToUI('INFO', `Sent 'lost' signal for session ${currentSessionId}.`);
         }
    }

    function stopGame() {
        logToUI('INFO', 'Stopping game animation/state.');
        isGameActive = false;
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        // Reset potentially sensitive game state vars
        // currentSessionId = null; // Keep session ID if needed for final message? No, reset.
        // currentStake = 0;
        // currentToken = '';
        multiplier = 1.0;

        resetToStartScreen();
        WebApp.disableClosingConfirmation();
    }

     function resetToStartScreen() {
         logToUI('DEBUG', 'Resetting UI to start screen state.');
         stakeControls.style.display = 'flex'; // Show stake controls again
         gameInterface.style.display = 'none';
         setupMainButton(); // Reset Main Button to "Start Climbing"
         // Don't reset status message here, let caller do it
     }

    // --- Initial Check ---
    // Check immediately if SDK exists, useful if script loads very fast
    if (window.Telegram && window.Telegram.WebApp && !isInitialized) {
        logToUI('INFO', 'SDK found synchronously, initializing.');
        initializeWebApp();
    } else if (!window.Telegram || !window.Telegram.WebApp) {
         logToUI('INFO', 'SDK not found synchronously, waiting for onload event.');
         // The onload handler on the script tag will call initializeWebApp
    }

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <title>Nims Climb - Ascent</title>
    <style>
        /* --- Basic Reset & Font --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Body Layout (Grid) --- */
        body {
            /* Updated background for a richer sky */
            background: linear-gradient(to bottom, #1a2a45, #2a3a5a, #4a5a7a);
            color: #e0e0e0; /* Lighter text color */
            min-height: 100vh;
            height: 100vh; /* Fix height to viewport */
            overflow: hidden;
            display: grid;
            grid-template-areas:
                "header header"
                "sidebar main"
                "controls controls";
            grid-template-columns: minmax(200px, 260px) 1fr; /* Slightly wider sidebar */
            grid-template-rows: auto 1fr auto;
            gap: 5px;
        }

        /* --- Header --- */
        #header {
            grid-area: header;
            background: rgba(22, 33, 62, 0.85); /* Semi-transparent header */
            backdrop-filter: blur(5px); /* Frosted glass effect */
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #balance {
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            text-align: right;
            font-weight: 500;
        }
        #balance span { /* Style token names */
             color: #ffc107; /* Gold-like color for BNB/NIMS */
             font-weight: bold;
        }


        /* --- Sidebar --- */
        #sidebar {
            grid-area: sidebar;
            background: rgba(15, 52, 96, 0.8); /* Darker, semi-transparent */
            backdrop-filter: blur(5px);
            padding: 0.75rem;
            overflow-y: auto;
            max-height: calc(100vh - 100px); /* Adjust based on header/controls height */
            z-index: 5;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Custom scrollbar for sidebar */
        #sidebar::-webkit-scrollbar { width: 6px; }
        #sidebar::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        #sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px;}


        #sidebar h3 {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.3rem;
            color: #ffca28; /* Header color */
            font-weight: 600;
        }

        #sidebar button, .sidebar-info button {
            width: 100%;
            padding: 0.7rem 0.5rem; /* Increased padding slightly */
            margin: 0.4rem 0;
            background: linear-gradient(145deg, #e94560, #b83048); /* Gradient button */
            border: none;
            border-radius: 5px;
            color: #fff;
            font-size: clamp(0.85rem, 2.5vw, 0.95rem);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            touch-action: manipulation;
        }
         .sidebar-info button { /* Refresh button style */
            width: auto;
            padding: 0.2rem 0.5rem;
            margin-left: 8px;
            font-size: 0.75rem;
            vertical-align: middle;
            background: rgba(255, 255, 255, 0.2);
             box-shadow: none;
             text-shadow: none;
        }
        .sidebar-info button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #sidebar button:hover:not(:disabled) {
            background: linear-gradient(145deg, #ff6b6b, #d44860);
            transform: translateY(-1px); /* Subtle lift effect */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }
         #sidebar button:active:not(:disabled) {
              transform: translateY(0px);
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
         }

         #sidebar button:disabled {
             background: #5a6268;
             cursor: not-allowed;
             opacity: 0.7;
             box-shadow: none;
         }

        .sidebar-info {
            margin: 0.75rem 0;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            background-color: rgba(22, 33, 62, 0.7); /* Match header */
            padding: 0.6rem 0.8rem;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        #leaderboard ul { list-style: none; padding: 0; }
        #leaderboard li {
            padding: 0.4rem 0.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
        }
        #leaderboard li:last-child { border-bottom: none; }
        #leaderboard li span:first-child { /* Rank/User ID */
             opacity: 0.8;
        }
         #leaderboard li span:last-child { /* Score */
             font-weight: bold;
             color: #ffeb3b; /* Yellow score */
         }


        /* --- Main Game Area (Canvas) --- */
        #game-container {
            grid-area: main;
            position: relative;
            overflow: hidden;
            /* Background gradient moved to body, container is for canvas layers */
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 1;
        }


        /* --- Controls --- */
        #controls {
            grid-area: controls;
            padding: 0.6rem 0.8rem;
            background: rgba(22, 33, 62, 0.85); /* Match header */
            backdrop-filter: blur(5px);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.6rem;
            z-index: 10;
             border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #stakeInput, #tokenSelect {
            padding: 0.7rem;
            border-radius: 4px;
            border: 1px solid #555;
            background: #f0f0f0;
            color: #333;
            font-size: clamp(0.85rem, 2.5vw, 0.95rem);
            max-width: 130px;
            text-align: center;
            font-weight: 500;
        }
        #stakeInput { -moz-appearance: textfield; }
         #stakeInput::-webkit-outer-spin-button,
         #stakeInput::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }


        #controls button {
            padding: 0.7rem 1.2rem;
            border: none;
            border-radius: 5px;
            background: linear-gradient(145deg, #e94560, #b83048); /* Match sidebar buttons */
            color: #fff;
            font-size: clamp(0.9rem, 3vw, 1.05rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            touch-action: manipulation;
            flex-grow: 1;
            max-width: 160px;
        }
        #controls button:disabled {
            background: #5a6268;
            cursor: not-allowed;
             opacity: 0.7;
             box-shadow: none;
             text-shadow: none;
        }
         #controls button:hover:not(:disabled) {
            background: linear-gradient(145deg, #ff6b6b, #d44860);
             transform: translateY(-1px); /* Subtle lift effect */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
         }
         #controls button:active:not(:disabled) {
              transform: translateY(0px);
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
         }

        /* --- Modal --- */
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.88); /* Darker overlay */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background: #1f2940; /* Dark modal background */
            padding: 1.5rem 2rem;
            border-radius: 8px;
            width: min(90%, 450px);
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal-content h2 {
            margin-bottom: 1.5rem;
            color: #ffca28;
            font-weight: 600;
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            word-wrap: break-word;
            white-space: pre-wrap;
            color: #c0c0c0; /* Lighter paragraph text */
            line-height: 1.5;
        }
        .modal-content p strong { /* Highlight addresses */
            color: #ffeb3b;
            word-break: break-all; /* Ensure long addresses break */
        }

        .modal-content input {
            width: 100%;
            padding: 0.8rem;
            margin: 0.7rem 0;
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #2a3a5a; /* Darker input background */
            color: #e0e0e0;
            font-size: clamp(0.9rem, 3vw, 1rem);
        }
         .modal-content input::placeholder { color: #888; }

        .modal-buttons {
            margin-top: 1.5rem;
            display: flex;
            gap: 0.8rem;
            justify-content: center;
        }

        .modal-buttons button {
             padding: 0.7rem 1.2rem;
             border: none;
             border-radius: 5px;
             font-size: clamp(0.9rem, 3vw, 1rem);
             font-weight: 500;
             cursor: pointer;
             transition: background 0.2s;
             background: #4a5a7a; /* Close button color */
             color: #e0e0e0;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
         .modal-buttons button.submit-button {
            background: #e94560;
            color: white;
         }
         .modal-buttons button.submit-button:hover { background: #ff6b6b; }
         .modal-buttons button:hover { background: #5a6a8a; }


        /* --- Notifications --- */
        .notification {
            position: fixed;
            top: 75px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.9);
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 6px;
            display: none;
            z-index: 999;
            font-size: clamp(0.9rem, 3vw, 1rem);
            font-weight: 500;
            text-align: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(3px);
            animation: fadeInOut 3s ease-in-out forwards; /* Use forwards to keep opacity 0 */
        }
        #cashout-message { background: rgba(60, 179, 113, 0.9); } /* Greenish */
        #rest-message { background: rgba(255, 165, 0, 0.9); } /* Orangish */

        @keyframes fadeInOut {
          0% { opacity: 0; transform: translate(-50%, -20px); }
          15% { opacity: 1; transform: translate(-50%, 0); }
          85% { opacity: 1; transform: translate(-50%, 0); }
          100% { opacity: 0; transform: translate(-50%, -20px); }
        }


        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            body {
                grid-template-areas:
                    "header"
                    "main"
                    "controls"
                    "sidebar";
                grid-template-columns: 1fr;
                grid-template-rows: auto minmax(250px, 1fr) auto auto;
                overflow-y: auto; /* Allow body scrolling if needed */
                height: auto; /* Allow content to determine height */
                min-height: 100vh;
            }
            #sidebar {
                max-height: none;
                overflow-y: visible;
                background: #0f3460; /* Make opaque */
                border-right: none;
                 border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
            #controls {
                flex-direction: column;
                align-items: stretch;
            }
            #stakeInput, #tokenSelect, #controls button {
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            #header, #controls { padding: 0.5rem; gap: 0.5rem;}
            #balance { text-align: center; }
            #stakeInput, #tokenSelect, #controls button, #sidebar button {
                 padding: 0.6rem; font-size: 0.9rem;
            }
            .modal-content { padding: 1rem 1.2rem; }
            .modal-content h2 { font-size: 1.3rem; margin-bottom: 1rem; }
            .modal-content p { margin-bottom: 1rem; }
            .modal-buttons button { padding: 0.6rem 1rem; font-size: 0.9rem; }
        }

         /* --- Animation --- */
        @keyframes shake { /* Screen shake */
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-4px, 2px); }
            20%, 40%, 60%, 80% { transform: translate(4px, -2px); }
        }
        .shake-effect { animation: shake 0.3s linear; }

        @keyframes pulseGlow { /* Subtle glow for multiplier */
           0%, 100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
           50% { text-shadow: 0 0 15px rgba(255, 255, 255, 0.8); }
        }

    </style>
</head>
<body>
    <div id="header">
        <div id="balance"><span>BNB:</span> 0 | <span>NIMS:</span> 0</div>
    </div>

    <div id="sidebar">
        <button onclick="showModal('deposit')">Deposit Address</button>
        <button onclick="showModal('withdraw')">Withdraw Funds</button>
        <button onclick="showModal('buy_raffle')">Buy Raffle Tickets</button>

        <div id="jackpot" class="sidebar-info">Community Jackpot: 0 NIMS</div>
        <div id="raffle" class="sidebar-info">
            Earned Tickets: 0 | Purchased: 0
            <button onclick="refreshTickets()">Refresh</button>
        </div>

        <div id="leaderboard">
            <h3>Leaderboard</h3>
            <ul id="leaderboard-list"><li>Loading...</li></ul>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="controls">
        <input type="number" id="stakeInput" placeholder="Stake" step="0.1" min="0.1" max="10">
        <select id="tokenSelect">
            <option value="BNB">BNB</option>
            <option value="NIMS">NIMS</option>
        </select>
        <button id="startButton">Start Climb</button>
        <button id="cashoutButton" disabled>Cash Out</button>
        <button id="restButton" disabled>Rest</button>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-body"></p>
            <input id="withdraw-amount" type="number" placeholder="Amount to withdraw" style="display: none;">
            <input id="withdraw-address" type="text" placeholder="Your BEP-20 Address" style="display: none;">
            <input id="ticket-amount" type="number" placeholder="Number of Tickets (1 NIMS each)" min="1" style="display: none;">
            <div class="modal-buttons">
                 <button onclick="closeModal()">Close</button>
                 <button id="withdraw-submit" class="submit-button" onclick="submitWithdrawal()" style="display: none;">Submit Withdrawal</button>
                 <button id="ticket-submit" class="submit-button" onclick="buyRaffleTickets()" style="display: none;">Buy Tickets</button>
            </div>
        </div>
    </div>

    <div id="error" class="notification">Error Message</div>
    <div id="cashout-message" class="notification">Cashout Message</div>
    <div id="rest-message" class="notification">Rest Message</div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const balanceDisplay = document.getElementById('balance');
        const stakeInput = document.getElementById('stakeInput');
        const tokenSelect = document.getElementById('tokenSelect');
        const startButton = document.getElementById('startButton');
        const cashoutButton = document.getElementById('cashoutButton');
        const restButton = document.getElementById('restButton');
        const errorDisplay = document.getElementById('error');
        const cashoutMessage = document.getElementById('cashout-message');
        const restMessage = document.getElementById('rest-message'); // Added rest message element
        const jackpotDisplay = document.getElementById('jackpot');
        const raffleDisplay = document.getElementById('raffle');
        const leaderboardList = document.getElementById('leaderboard-list');
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const withdrawAmountInput = document.getElementById('withdraw-amount');
        const withdrawAddressInput = document.getElementById('withdraw-address');
        const withdrawSubmitBtn = document.getElementById('withdraw-submit');
        const ticketAmountInput = document.getElementById('ticket-amount');
        const ticketSubmitBtn = document.getElementById('ticket-submit');

        // --- Telegram WebApp Initialization ---
        const tg = window.Telegram.WebApp;

        // --- Game State Variables ---
        let gameData = null;
        let sessionId = null;
        let currentStake = 0;
        let currentToken = 'BNB';
        let crashPoint = 0; // The multiplier where the avalanche hits
        let currentMultiplier = 1.0;
        let timeElapsed = 0; // Seconds since game start
        let isGameRunning = false;
        let animationFrameId = null;
        let lastTimestamp = 0;
        let hasCrashed = false;
        const safetyZones = [1.5, 3.0, 5.0];
        const ALTITUDE_FACTOR = 1000; // 1.0x = 1000m

        // --- Nims Character State ---
        const NIMS_STATE = { IDLE: 0, CLIMBING: 1, WAVING: 2, FALLING: 3 };
        let nims = {
            x: 50, y: 0, // Position
            size: 18,   // Increased size slightly
            angle: 0,
            state: NIMS_STATE.IDLE,
            climbFrame: 0, // 0 or 1 for climbing animation
            frameTimer: 0,
            frameDelay: 120, // ms between climb frames
            waveTimer: 0,
            waveDuration: 1500, // ms for waving animation
            fallSpeedY: 0
        };

        // --- Visual Effects State ---
        let particles = []; // General purpose particles (wind, maybe crash debris)
        let avalancheState = {
            active: false, progress: 0, duration: 1.2, // Slightly longer avalanche
            shakeIntensity: 4
        };
        let windGustTimer = 0;
        let nextWindGust = Math.random() * 5 + 3; // Time until next gust

        // --- Parallax Background State ---
        let parallaxOffset = 0; // How much the background has scrolled
        const parallaxLayers = [
             // Farthest layer (slowest scroll) - could be distant mountains or sky features
             { id: 'sky', depth: 0.05, color: '#1a2a45', elements: [] }, // Example: Clouds layer
             // Mountain Layers
             { id: 'mountain_far', depth: 0.15, color: '#253550', peaks: [] },
             { id: 'mountain_mid', depth: 0.3, color: '#354565', peaks: [] },
             { id: 'mountain_near', depth: 0.5, color: '#4a5a7a', peaks: [] },
             // Closest layer (fastest scroll) - could be foreground rocks/trees
             // { id: 'foreground', depth: 0.8, color: '#5a6a8a', elements: [] }
        ];
        // --- Altitude Graph State ---
        let altitudePath = []; // Array of {multiplier, yPos} points

        // --- UI Constants ---
        const GRAPH_EDGE_WIDTH = 40; // Width of the side bars for altitude markers


        // --- Utility Functions ---
        function lerp(a, b, t) { return a + (b - a) * t; } // Linear interpolation
        function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }

        function getQueryParam(param) { /* ... (same as before) ... */ }
        function showNotification(element, message) { /* ... (same as before, maybe adjust 'top' style) ... */ }
        function refreshTickets() { /* ... (same as before) ... */ }
        function showModal(type) {
            modal.style.display = 'flex';
            withdrawAmountInput.style.display = 'none';
            withdrawAddressInput.style.display = 'none';
            withdrawSubmitBtn.style.display = 'none';
            ticketAmountInput.style.display = 'none';
            ticketSubmitBtn.style.display = 'none';
            modalBody.style.whiteSpace = 'pre-wrap'; // Keep this

            if (!gameData) {
                modalTitle.textContent = "Error";
                modalBody.textContent = "Game data not loaded. Please restart.";
                return;
            }

            if (type === 'deposit') {
                modalTitle.textContent = 'Deposit Address (BEP-20)';
                const bnbAddr = gameData.bnb_address || 'N/A';
                const nimsAddr = gameData.nims_address || 'N/A';
                 // Using strong tags for addresses
                 modalBody.innerHTML = `Send only <strong>BNB</strong> (BEP-20) to:<br><strong>${bnbAddr}</strong><br><br>Send only <strong>NIMS</strong> (BEP-20) to:<br><strong>${nimsAddr}</strong>`;
            } else if (type === 'withdraw') {
                modalTitle.textContent = 'Withdraw Funds';
                 // Update to reflect current token if possible, otherwise generic
                 let withdrawToken = tokenSelect.value || 'currency';
                 modalBody.textContent = `Withdraw ${withdrawToken} (1% fee applies). Ensure the address is correct! Network: BEP-20.`;
                withdrawAmountInput.style.display = 'block';
                withdrawAddressInput.style.display = 'block';
                withdrawSubmitBtn.style.display = 'block';
                withdrawAmountInput.value = '';
                withdrawAddressInput.value = '';
                 withdrawAmountInput.placeholder = `Amount of ${withdrawToken}`;
            } else if (type === 'buy_raffle') {
                modalTitle.textContent = 'Buy Summit Raffle Tickets';
                modalBody.textContent = 'Enter number of tickets to purchase (1 NIMS each).';
                ticketAmountInput.style.display = 'block';
                ticketSubmitBtn.style.display = 'block';
                ticketAmountInput.value = '';
            }
        }
        function closeModal() { /* ... (same as before) ... */ }
        function submitWithdrawal() { /* ... (same as before, added BEP-20 check) ... */
             const address = withdrawAddressInput.value.trim();
             if (!address || !/^0x[a-fA-F0-9]{40}$/.test(address)) { // Stricter BEP-20 format check
                 showNotification(errorDisplay, 'Invalid BEP-20 address format.');
                 return;
             }
             // ... rest of validation and sending logic ...
        }
        function buyRaffleTickets() { /* ... (same as before) ... */ }


        // --- Canvas Drawing Functions ---

        function resizeCanvas() {
            const containerWidth = gameContainer.offsetWidth;
            const containerHeight = gameContainer.offsetHeight;
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            initBackgroundElements(); // Regenerate background based on new size
             altitudePath = []; // Clear altitude path on resize
            // Reset Nims Y position based on new height and potential edge bars
            nims.y = canvas.height - nims.size * 1.5;
            nims.x = GRAPH_EDGE_WIDTH + nims.size; // Start inside left edge bar

            drawFrame(); // Redraw immediately
        }

        // Initialize/Regenerate Parallax Elements
        function initBackgroundElements() {
             // Stars (similar to before)
             particles = particles.filter(p => p.type !== 'star'); // Clear old stars
             for (let i = 0; i < 150; i++) { // More stars
                 particles.push({
                     type: 'star',
                     x: Math.random() * canvas.width,
                     y: Math.random() * canvas.height * 0.9,
                     radius: Math.random() * 1.2 + 0.4,
                     alpha: Math.random() * 0.6 + 0.2
                 });
             }

             // Mountains (regenerate peaks)
             parallaxLayers.filter(l => l.id.includes('mountain')).forEach(range => {
                 range.peaks = generateMountainPeaks(range.depth);
             });

             // Clouds
             const cloudLayer = parallaxLayers.find(l=>l.id === 'sky');
             if (cloudLayer) {
                  cloudLayer.elements = []; // Clear old clouds
                  for (let i = 0; i < 5; i++) { // Add a few clouds
                       cloudLayer.elements.push({
                           x: Math.random() * canvas.width * 1.5 - canvas.width * 0.25, // Start scattered, including off-screen
                           y: canvas.height * (0.1 + Math.random() * 0.3), // Upper part of sky
                           width: 100 + Math.random() * 150,
                           height: 30 + Math.random() * 40,
                           speed: 5 + Math.random() * 10 // Pixels per second
                       });
                  }
             }
         }

        function generateMountainPeaks(depth) {
            const peaks = [];
             // Adjust height based on depth, ensuring higher peaks for closer ranges
            const baseHeight = canvas.height * (0.5 + (1 - depth) * 0.4);
            const roughness = 0.3 + depth * 0.5; // More jagged for distant ranges
            const peakWidth = (100 + (1 - depth) * 250);

            let currentX = -peakWidth; // Start off-screen left
            while (currentX < canvas.width + peakWidth) {
                const peakHeight = baseHeight - (50 + Math.random() * canvas.height * roughness); // Ensure peaks are below top
                 peaks.push({ x: currentX, y: clamp(peakHeight, canvas.height * 0.1, canvas.height) }); // Clamp Y
                currentX += peakWidth * (0.6 + Math.random() * 0.5);
            }
             // Ensure first and last points cover edges smoothly if needed
             if (peaks.length > 0) {
                  if (peaks[0].x > 0) peaks.unshift({x: -peakWidth*0.5, y: peaks[0].y});
                  if (peaks[peaks.length-1].x < canvas.width) peaks.push({x: canvas.width + peakWidth*0.5, y: peaks[peaks.length-1].y});
             }

            return peaks;
        }

        // Draw Parallax Background
        function drawBackground(deltaTime) {
             // Clear with body gradient (or draw gradient here if needed)
             // ctx.clearRect(0, 0, canvas.width, canvas.height);

             // Update parallax offset based on game progress (e.g., time or multiplier)
             if (isGameRunning) {
                  // Scroll faster as multiplier increases
                  const scrollSpeed = 10 + currentMultiplier * 5;
                  parallaxOffset += scrollSpeed * deltaTime;
             }

            // Draw Stars (static, or twinkle)
            particles.filter(p => p.type === 'star').forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * (0.8 + Math.sin(performance.now() / (1000 + star.radius * 100)) * 0.2) })`; // Twinkle effect
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });

             // Draw Parallax Layers (back to front)
             parallaxLayers.forEach(layer => {
                 const offsetX = (parallaxOffset * layer.depth) % canvas.width; // Simple wrap-around might need improvement

                 if (layer.id.includes('mountain')) {
                     ctx.fillStyle = layer.color;
                     ctx.beginPath();
                     // Calculate points based on offset - more complex for smooth wrapping
                     const startX = -offsetX;
                     ctx.moveTo(startX, canvas.height);
                     let currentLayerX = startX;

                     // Draw peaks for the current view and the wrapped-around view
                      for (let wrap = 0; wrap < 2; wrap++) { // Draw twice for wrapping
                          layer.peaks.forEach((peak, index) => {
                               const drawX = peak.x + startX + wrap * canvas.width; // WRAPPING IS SIMPLISTIC HERE
                               if (index === 0) {
                                   ctx.lineTo(drawX, peak.y);
                               } else {
                                   const prevPeak = layer.peaks[index - 1];
                                    const prevDrawX = prevPeak.x + startX + wrap * canvas.width;
                                    const cp1x = prevDrawX + (drawX - prevDrawX) * 0.3;
                                    const cp1y = prevPeak.y;
                                    const cp2x = drawX - (drawX - prevDrawX) * 0.3;
                                    const cp2y = peak.y;
                                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, drawX, peak.y);
                               }
                               currentLayerX = drawX; // Track last drawn X
                          });
                      }

                     ctx.lineTo(currentLayerX > canvas.width ? currentLayerX : canvas.width, canvas.height); // Extend to bottom right
                     ctx.lineTo(startX, canvas.height); // Back to start
                     ctx.closePath();
                     ctx.fill();

                 } else if (layer.id === 'sky' && layer.elements) { // Draw Clouds
                      layer.elements.forEach(cloud => {
                           // Update cloud position
                           cloud.x -= cloud.speed * deltaTime * layer.depth; // Move based on depth
                           // Simple wrapping
                           if (cloud.x + cloud.width < 0) {
                                cloud.x = canvas.width + Math.random() * 50;
                                cloud.y = canvas.height * (0.1 + Math.random() * 0.3); // Reset Y slightly
                           }

                           // Draw soft cloud shape
                           ctx.fillStyle = `rgba(255, 255, 255, 0.7)`; // Semi-transparent white
                           ctx.beginPath();
                           ctx.ellipse(cloud.x + cloud.width / 2, cloud.y + cloud.height / 2, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                           ctx.fill();
                           // Add more ellipses for cloud fluffiness
                           ctx.ellipse(cloud.x + cloud.width * 0.2, cloud.y + cloud.height * 0.8, cloud.width * 0.3, cloud.height * 0.3, 0, 0, Math.PI*2);
                           ctx.ellipse(cloud.x + cloud.width * 0.8, cloud.y + cloud.height * 0.7, cloud.width * 0.4, cloud.height * 0.4, 0, 0, Math.PI*2);
                           ctx.fill();

                      });
                 }
                 // Add drawing for other layer types ('foreground') if needed
             });
        }


        // --- Path & Nims Position Calculation ---
        function getClimbPosition(multiplierValue) {
            // Non-linear progress: faster climb at higher multipliers
            // Example: progress proportional to log(multiplier) initially, then accelerates
            let progress = Math.log(Math.max(1, multiplierValue)) / Math.log(20); // Normalizing factor (adjust 20 as needed)
             progress = Math.pow(progress, 0.8) + Math.pow(Math.max(0, multiplierValue - 1.5), 1.2) * 0.05; // Accelerate after 1.5x

            const climbHeight = canvas.height * 0.85; // Max climb area height
            const climbWidth = canvas.width - GRAPH_EDGE_WIDTH * 2 - nims.size * 2; // Available width

            // Zigzag pattern or curved path
             let pathX = GRAPH_EDGE_WIDTH + nims.size + (climbWidth / 2) * (1 + Math.sin(progress * Math.PI * 2) * 0.8); // Sin wave horizontal movement
             let pathY = canvas.height - nims.size * 1.5 - progress * climbHeight;

             // Clamp Y position
             pathY = clamp(pathY, nims.size * 2, canvas.height - nims.size * 1.5);
             // Clamp X position within the edges
             pathX = clamp(pathX, GRAPH_EDGE_WIDTH + nims.size, canvas.width - GRAPH_EDGE_WIDTH - nims.size);


            // Calculate angle based on change (more robustly)
            const prevMultiplier = Math.max(1, multiplierValue * 0.99); // Check slightly behind
            const prevPos = getClimbPosition(prevMultiplier); // Simplified - avoid infinite recursion in real use
            let dx = pathX - prevPos.x;
            let dy = pathY - prevPos.y; // Note: dy is negative for upward movement
            let angle = Math.atan2(dy, dx) + Math.PI / 2; // Angle perpendicular to movement + offset for climbing up

            // Add slight wobble/sway
            angle += Math.sin(performance.now() / 300) * 0.05;

            return { x: pathX, y: pathY, angle: angle };
        }

        // Draw Altitude Graph Curve
        function drawAltitudeGraph() {
            if (!altitudePath.length) return;

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; // Yellowish graph line
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            const startPoint = altitudePath[0];
            ctx.moveTo(startPoint.x, startPoint.y);

            altitudePath.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Optional: Add glowing effect to the head of the graph line
            const lastPoint = altitudePath[altitudePath.length - 1];
            if (lastPoint) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.shadowColor = 'yellow';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(lastPoint.x, lastPoint.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }

        // Draw Altitude Markers on Edges
        function drawGraphEdges() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Semi-transparent background for edges
            ctx.fillRect(0, 0, GRAPH_EDGE_WIDTH, canvas.height);
            ctx.fillRect(canvas.width - GRAPH_EDGE_WIDTH, 0, GRAPH_EDGE_WIDTH, canvas.height);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(GRAPH_EDGE_WIDTH, 0);
            ctx.lineTo(GRAPH_EDGE_WIDTH, canvas.height);
            ctx.moveTo(canvas.width - GRAPH_EDGE_WIDTH, 0);
            ctx.lineTo(canvas.width - GRAPH_EDGE_WIDTH, canvas.height);
            ctx.stroke();

            // Add Altitude Markers
            const maxAltitude = (crashPoint || 10) * ALTITUDE_FACTOR; // Estimate max based on crash or typical max
            const step = 1000; // Marker every 1000m
            ctx.fillStyle = '#ffeb3b'; // Yellow marker text
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let alt = step; alt <= maxAltitude; alt += step) {
                 const multiplierEquiv = alt / ALTITUDE_FACTOR;
                 // Only draw markers below the current crash point if known
                 if (crashPoint > 0 && multiplierEquiv > crashPoint * 1.1) continue;

                 const pos = getClimbPosition(multiplierEquiv); // Get Y position for this altitude

                 // Draw marker line and text on both sides
                 if (pos.y < canvas.height - 10 && pos.y > 10) { // Only if on screen
                     ctx.strokeStyle = 'rgba(255, 235, 59, 0.5)'; // Yellowish line
                      ctx.lineWidth = 1;
                      ctx.beginPath();
                      ctx.moveTo(GRAPH_EDGE_WIDTH - 5, pos.y);
                      ctx.lineTo(GRAPH_EDGE_WIDTH, pos.y);
                      ctx.moveTo(canvas.width - GRAPH_EDGE_WIDTH, pos.y);
                      ctx.lineTo(canvas.width - GRAPH_EDGE_WIDTH + 5, pos.y);
                      ctx.stroke();

                      ctx.fillText(`${alt}m`, GRAPH_EDGE_WIDTH / 2, pos.y);
                      ctx.fillText(`${alt}m`, canvas.width - GRAPH_EDGE_WIDTH / 2, pos.y);
                 }

            }
        }

        // Draw Nims Character (Enhanced)
        function drawNims(deltaTime) {
            if (nims.state === NIMS_STATE.IDLE && !isGameRunning && !hasCrashed) return;

            const pos = getClimbPosition(currentMultiplier);
            nims.x = pos.x; // Update position directly for falling state
            nims.y = pos.y;
            nims.angle = pos.angle;

            // Update Nims state based on game state
            if (hasCrashed && nims.state !== NIMS_STATE.FALLING) {
                nims.state = NIMS_STATE.FALLING;
                nims.fallSpeedY = 0; // Start falling
            } else if (isGameRunning) {
                if (nims.state === NIMS_STATE.IDLE || nims.state === NIMS_STATE.FALLING) {
                    nims.state = NIMS_STATE.CLIMBING;
                    nims.frameTimer = 0;
                }
                // Check for waving milestones
                 if (nims.state !== NIMS_STATE.WAVING) {
                     if (Math.abs(currentMultiplier - 2.0) < 0.05 || Math.abs(currentMultiplier - 5.0) < 0.05) {
                          nims.state = NIMS_STATE.WAVING;
                          nims.waveTimer = 0;
                     }
                 }
            } else if (!hasCrashed) {
                 nims.state = NIMS_STATE.IDLE;
            }


            // --- Animation Logic ---
            nims.frameTimer += deltaTime * 1000; // Timer in ms

            if (nims.state === NIMS_STATE.CLIMBING) {
                if (nims.frameTimer >= nims.frameDelay) {
                    nims.climbFrame = 1 - nims.climbFrame; // Toggle climb frame
                    nims.frameTimer = 0;
                }
            } else if (nims.state === NIMS_STATE.WAVING) {
                 nims.waveTimer += deltaTime * 1000;
                 if (nims.waveTimer >= nims.waveDuration) {
                     nims.state = NIMS_STATE.CLIMBING; // Go back to climbing
                 }
            } else if (nims.state === NIMS_STATE.FALLING) {
                 // Apply gravity
                 nims.fallSpeedY += 9.81 * 50 * deltaTime; // Adjust gravity factor
                 nims.y += nims.fallSpeedY * deltaTime;
                 nims.angle += 5 * deltaTime; // Spin while falling
            }

            // --- Drawing Logic ---
            ctx.save();
            ctx.translate(nims.x, nims.y);
            ctx.rotate(nims.angle);

            // Nims Colors
            const headColor = '#f0c0a0';
            const bodyColor = '#d04040'; // Red suit
            const limbColor = '#a03030'; // Darker limbs

            // Draw Body Parts
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            // Torso (simple rectangle)
            ctx.rect(-nims.size * 0.3, -nims.size * 0.4, nims.size * 0.6, nims.size * 0.8);
            ctx.fill();

            // Head (circle on top)
            ctx.fillStyle = headColor;
            ctx.beginPath();
            ctx.arc(0, -nims.size * 0.6, nims.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            // Simple eye
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(nims.size * 0.15, -nims.size * 0.65, nims.size * 0.08, 0, Math.PI * 2);
            ctx.fill();


            // Limbs
            ctx.strokeStyle = limbColor;
            ctx.lineWidth = nims.size * 0.2;
            ctx.lineCap = 'round';

            if (nims.state === NIMS_STATE.CLIMBING) {
                const armAngle1 = nims.climbFrame === 0 ? -0.5 : 0.8;
                const armAngle2 = nims.climbFrame === 0 ? 0.6 : -0.7;
                const legAngle1 = nims.climbFrame === 0 ? 1.8 : 2.5;
                const legAngle2 = nims.climbFrame === 0 ? 2.8 : 1.5;

                // Draw Arms
                ctx.beginPath();
                ctx.moveTo(0, -nims.size * 0.2); // Shoulder
                ctx.lineTo(Math.cos(armAngle1) * nims.size * 0.6, -nims.size * 0.2 + Math.sin(armAngle1) * nims.size * 0.6);
                ctx.moveTo(0, -nims.size * 0.2); // Shoulder
                ctx.lineTo(Math.cos(armAngle2) * nims.size * 0.6, -nims.size * 0.2 + Math.sin(armAngle2) * nims.size * 0.6);
                ctx.stroke();

                // Draw Legs
                ctx.beginPath();
                ctx.moveTo(0, nims.size * 0.4); // Hip
                ctx.lineTo(Math.cos(legAngle1) * nims.size * 0.7, nims.size * 0.4 + Math.sin(legAngle1) * nims.size * 0.7);
                ctx.moveTo(0, nims.size * 0.4); // Hip
                ctx.lineTo(Math.cos(legAngle2) * nims.size * 0.7, nims.size * 0.4 + Math.sin(legAngle2) * nims.size * 0.7);
                ctx.stroke();

            } else if (nims.state === NIMS_STATE.WAVING) {
                 // Waving arm animation
                 const waveAngle = -0.5 + Math.sin(nims.waveTimer / 100) * 0.5; // Simple back and forth
                 ctx.beginPath();
                 ctx.moveTo(0, -nims.size * 0.2); // Shoulder
                 ctx.lineTo(Math.cos(waveAngle) * nims.size * 0.6, -nims.size * 0.2 + Math.sin(waveAngle) * nims.size * 0.6);
                 // Other limbs static or slightly different pose
                 ctx.moveTo(0, -nims.size * 0.2); ctx.lineTo(0.5 * nims.size * 0.6, -nims.size * 0.2 + 0.8 * nims.size * 0.6);
                 ctx.moveTo(0, nims.size * 0.4); ctx.lineTo(Math.cos(2.0) * nims.size * 0.7, nims.size * 0.4 + Math.sin(2.0) * nims.size * 0.7);
                 ctx.moveTo(0, nims.size * 0.4); ctx.lineTo(Math.cos(2.5) * nims.size * 0.7, nims.size * 0.4 + Math.sin(2.5) * nims.size * 0.7);
                 ctx.stroke();
            } else if (nims.state === NIMS_STATE.FALLING) {
                 // Limbs flailing while falling
                 const flailAngle = Math.sin(performance.now() / 50) * 0.5;
                 ctx.beginPath();
                 ctx.moveTo(0, -nims.size * 0.2); ctx.lineTo(Math.cos(-0.5 + flailAngle) * nims.size * 0.6, -nims.size * 0.2 + Math.sin(-0.5+flailAngle) * nims.size * 0.6);
                 ctx.moveTo(0, -nims.size * 0.2); ctx.lineTo(Math.cos(0.5 - flailAngle) * nims.size * 0.6, -nims.size * 0.2 + Math.sin(0.5-flailAngle) * nims.size * 0.6);
                 ctx.moveTo(0, nims.size * 0.4); ctx.lineTo(Math.cos(2.0 + flailAngle) * nims.size * 0.7, nims.size * 0.4 + Math.sin(2.0+flailAngle) * nims.size * 0.7);
                 ctx.moveTo(0, nims.size * 0.4); ctx.lineTo(Math.cos(2.5 - flailAngle) * nims.size * 0.7, nims.size * 0.4 + Math.sin(2.5-flailAngle) * nims.size * 0.7);
                 ctx.stroke();
            }


            // Draw Altitude Text near Nims (only if not falling)
             if (nims.state !== NIMS_STATE.FALLING) {
                  ctx.fillStyle = '#FFFFFF';
                  ctx.font = 'bold 14px Arial';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'bottom';
                  // Apply subtle pulse animation via text shadow
                  const pulse = Math.sin(performance.now() / 200) * 3 + 7; // Glow radius oscillates
                  ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                  ctx.shadowBlur = pulse;
                  ctx.fillText(`Alt: ${(currentMultiplier * ALTITUDE_FACTOR).toFixed(0)}m`, 0, -nims.size); // Position above head
                  ctx.shadowBlur = 0; // Reset shadow
             }

            ctx.restore();
        }

        // Draw Particles (Wind, Debris)
        function drawParticles(deltaTime) {
             // Update Wind Gust Timer
             windGustTimer += deltaTime;
             if (windGustTimer >= nextWindGust) {
                 // Trigger a wind gust
                 for (let i = 0; i < 20; i++) { // Add gust particles
                     particles.push({
                         type: 'wind',
                         x: -10, // Start from left edge
                         y: Math.random() * canvas.height,
                         radius: Math.random() * 1.5 + 0.5,
                         speedX: 150 + Math.random() * 100,
                         speedY: (Math.random() - 0.5) * 20,
                         alpha: Math.random() * 0.3 + 0.2,
                         life: 2 // seconds
                     });
                 }
                 windGustTimer = 0;
                 nextWindGust = Math.random() * 8 + 5; // Reset timer for next gust
             }

             // Update and draw all particles
             for (let i = particles.length - 1; i >= 0; i--) {
                 const p = particles[i];
                 p.x += (p.speedX || 0) * deltaTime;
                 p.y += (p.speedY || 0) * deltaTime;
                 p.life -= deltaTime;

                 if (p.life <= 0 || p.x > canvas.width + 10 || p.x < -10 || p.y > canvas.height + 10 || p.y < -10) {
                     particles.splice(i, 1); // Remove dead or off-screen particles
                 } else {
                     if (p.type === 'wind') {
                          ctx.fillStyle = `rgba(200, 200, 220, ${p.alpha * (p.life / 2)})`; // Fade out as life decreases
                          ctx.beginPath();
                          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                          ctx.fill();
                     } else if (p.type === 'avalanche') {
                          ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                          ctx.beginPath();
                          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                          ctx.fill();
                     }
                     // Draw other particle types ('star' handled in drawBackground)
                 }
             }
        }


         // Draw Avalanche Effect (Enhanced)
        function drawAvalanche(deltaTime) {
            if (!avalancheState.active) return;

            avalancheState.progress += deltaTime / avalancheState.duration;
            avalancheState.progress = Math.min(avalancheState.progress, 1);

            // 1. Screen Shake
            const shakeX = (Math.random() - 0.5) * 2 * avalancheState.shakeIntensity * (1 - avalancheState.progress);
            const shakeY = (Math.random() - 0.5) * 2 * avalancheState.shakeIntensity * (1 - avalancheState.progress);
            ctx.translate(shakeX, shakeY); // Apply shake globally for this frame

            // 2. Avalanche Particles
            if (avalancheState.progress < 1) {
                 for (let i = 0; i < 15; i++) { // More particles
                     particles.push({
                         type: 'avalanche',
                         x: Math.random() * canvas.width,
                         y: -10, // Start above screen
                         radius: Math.random() * 4 + 2, // Larger snow chunks
                         speedY: 200 + Math.random() * 200, // Faster
                         speedX: (Math.random() - 0.5) * 80,
                         alpha: Math.random() * 0.6 + 0.4,
                         life: 1.5
                     });
                 }
            }
             // Particle drawing happens in drawParticles()

            // 3. White Overlay / Fog
            ctx.fillStyle = `rgba(220, 220, 235, ${avalancheState.progress * 0.6})`; // More opaque, slightly blueish white fog
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 4. "AVALANCHE!" Text (Larger, more impactful)
            if (avalancheState.progress > 0.1) {
                 ctx.font = `bold ${clamp(60 * avalancheState.progress, 20, 60)}px Arial Black, sans-serif`; // Grow text size
                 ctx.fillStyle = 'rgba(180, 0, 0, 0.85)';
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                 ctx.shadowBlur = 5;
                 ctx.shadowOffsetX = 2;
                 ctx.shadowOffsetY = 2;
                 ctx.fillText('AVALANCHE!', canvas.width / 2, canvas.height / 2);
                 ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; // Reset shadow
            }

            // Check for animation end condition
            if (avalancheState.progress >= 1 && particles.filter(p => p.type === 'avalanche').length === 0) {
                avalancheState.active = false;
                resetGameVisuals(); // Reset visuals AFTER animation fully completes
                startButton.disabled = false; // Re-enable start button AFTER crash sequence
                console.log('Avalanche animation finished.');
            }
        }


        // --- Game Logic ---

        function updateLeaderboard() { /* ... (same as before, maybe add rank #) ... */
             leaderboardList.innerHTML = ''; // Clear previous entries
            if (gameData && gameData.leaderboard && Array.isArray(gameData.leaderboard) && gameData.leaderboard.length > 0) {
                gameData.leaderboard.slice(0, 7).forEach((entry, index) => { // Show top 7
                    const li = document.createElement('li');
                    const rankSpan = `<span>#${index + 1} U:${entry.user_id}</span>`;
                    const scoreSpan = `<span>${parseFloat(entry.highest_cashout || 0).toFixed(2)}x</span>`;
                    li.innerHTML = rankSpan + scoreSpan;
                    leaderboardList.appendChild(li);
                });
            } else {
                leaderboardList.innerHTML = '<li>No leaderboard data yet.</li>';
            }
         }

        // Main game loop function
        function gameLoop(timestamp) {
             if (!isGameRunning && !avalancheState.active && nims.state !== NIMS_STATE.FALLING) {
                 animationFrameId = null; lastTimestamp = 0; return; // Stop loop if idle
             }

            const deltaTime = lastTimestamp ? (timestamp - lastTimestamp) / 1000 : 0;
            lastTimestamp = timestamp;
             // Cap delta time to prevent huge jumps if tabbed away
             const dt = Math.min(deltaTime, 0.1);

            if (isGameRunning) {
                 timeElapsed += dt;
                 // Adjust multiplier growth - slightly faster curve
                 const baseRate = 0.3;
                 const acceleration = 0.05; // How much the rate increases over time/multiplier
                 const currentRate = baseRate + Math.log1p(Math.max(0, currentMultiplier - 1)) * acceleration;
                 currentMultiplier += currentRate * dt * currentMultiplier * 0.5; // Multiplier affects its own growth rate
                 currentMultiplier = Math.max(1.0, currentMultiplier);

                 // Add current position to altitude graph path
                 const currentPos = getClimbPosition(currentMultiplier);
                 altitudePath.push({ x: currentPos.x, y: currentPos.y, multiplier: currentMultiplier });
                 // Optional: Limit path length for performance
                 // if (altitudePath.length > 500) altitudePath.shift();


                 // Check for crash
                 if (crashPoint > 0 && currentMultiplier >= crashPoint) {
                     console.log(`Crash condition met: Multiplier ${currentMultiplier.toFixed(4)} >= Crash Point ${crashPoint}`);
                     triggerCrash();
                 } else {
                     // Update button states
                     cashoutButton.disabled = false;
                      // Enable rest button if near ANY safety zone
                      restButton.disabled = !safetyZones.some(zone => Math.abs(currentMultiplier - zone) < 0.15); // Slightly larger tolerance
                 }
            }

             // Draw everything for the frame
             drawFrame(dt);

            // Request next frame
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Combined drawing function
        function drawFrame(deltaTime = 0) {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             ctx.save(); // Save clean state

             // Draw Parallax Background
             drawBackground(deltaTime);

             // Draw Graph Edges and Markers
             drawGraphEdges();

             // Draw Altitude Graph Curve
             drawAltitudeGraph();

             // Draw Particles (Wind, Debris)
             drawParticles(deltaTime);

             // Draw Nims Character
             drawNims(deltaTime);

             // Draw Avalanche Effect (if active) - this also applies screen shake
             if (avalancheState.active) {
                 drawAvalanche(deltaTime);
             }

             ctx.restore(); // Restore clean state (removes shake if applied)
        }


        function triggerCrash() {
            if (hasCrashed) return;
            console.log('Triggering crash...');
            hasCrashed = true;
            isGameRunning = false;
            currentMultiplier = crashPoint; // Lock multiplier visually

            // Disable controls
            cashoutButton.disabled = true;
            restButton.disabled = true;
            startButton.disabled = true; // Keep start disabled during animation

            // Start avalanche animation
            avalancheState.active = true;
            avalancheState.progress = 0;
            // Particles added within drawAvalanche

            // Send 'lost' message
            if (tg && sessionId) { /* ... (same as before) ... */ }

             // Ensure loop continues for animation
            if (!animationFrameId) { animationFrameId = requestAnimationFrame(gameLoop); }
        }


        // Reset game state and visuals
        function resetGameVisuals() {
            console.log('Resetting game visuals to idle state...');
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

            isGameRunning = false; hasCrashed = false;
            currentMultiplier = 1.0; timeElapsed = 0; lastTimestamp = 0;
            sessionId = null; crashPoint = 0;
            altitudePath = []; // Clear graph path
            particles = particles.filter(p => p.type === 'star'); // Keep stars, clear others

            // Reset Nims
            nims.state = NIMS_STATE.IDLE;
            nims.y = canvas.height - nims.size * 1.5;
            nims.x = GRAPH_EDGE_WIDTH + nims.size;
            nims.angle = 0; nims.climbFrame = 0; nims.frameTimer = 0; nims.waveTimer = 0; nims.fallSpeedY = 0;

            // Reset Buttons
            stakeInput.disabled = false; tokenSelect.disabled = false;
            startButton.disabled = false; cashoutButton.disabled = true; restButton.disabled = true;

             // Ensure avalanche state is fully off
            avalancheState.active = false; avalancheState.progress = 0;

            // Redraw the initial idle frame
            drawFrame();
        }

        function validateStake() { /* ... (same as before) ... */ }

        // --- Event Listeners ---

        startButton.addEventListener('click', () => { /* ... (same as before, ensure resetGameVisuals() is called first) ... */
            if (!validateStake()) return;
            if (!gameData) { /* ... error ... */ return; }
            currentStake = parseFloat(stakeInput.value);
            currentToken = tokenSelect.value;
            // ... (balance check logic as before) ...

            console.log(`Requesting start: Stake=${currentStake}, Token=${currentToken}`);
             resetGameVisuals(); // Ensure clean state before sending request

            // Disable controls
            startButton.disabled = true; stakeInput.disabled = true; tokenSelect.disabled = true;
            cashoutButton.disabled = true; restButton.disabled = true;

             if (tg) { /* ... sendData 'start_game' ... */ }
             else { /* ... error, resetGameVisuals() ... */ }
        });

        cashoutButton.addEventListener('click', () => {
            if (!isGameRunning || !sessionId) return;
            console.log(`Requesting cashout: Mult=${currentMultiplier.toFixed(4)}, Sess=${sessionId}`);

            isGameRunning = false; // Stop game logic
            cashoutButton.disabled = true; restButton.disabled = true; startButton.disabled = true;

             showNotification(cashoutMessage, `Cashed out at ${currentMultiplier.toFixed(2)}x!`); // Provide immediate feedback

            if (tg) { /* ... sendData 'cashout' ... */ }
            else { /* ... error, resetGameVisuals() ... */ }

            // Don't reset visuals immediately, wait for backend update / next game start
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } // Stop loop
             // Draw one last frame showing the cashed-out state? Optional.
             // drawFrame();
        });

        restButton.addEventListener('click', () => {
            if (!isGameRunning || !sessionId) return;
             // ... (Find closest targetZone as before) ...
             if (targetZone === 0) { /* ... error ... */ return; }

             console.log(`Requesting rest: Zone=${targetZone}x, Sess=${sessionId}`);
             isGameRunning = false; // Stop game logic
             cashoutButton.disabled = true; restButton.disabled = true; startButton.disabled = true;

             showNotification(restMessage, `Resting at ${targetZone}x...`); // Use dedicated rest message

             if (tg) { /* ... sendData 'rest' ... */ }
             else { /* ... error, resetGameVisuals() ... */ }

             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } // Stop loop
        });

        window.addEventListener('resize', resizeCanvas);


        // --- Initialization ---
        function initializeApp() {
            console.log('Initializing Nims Climb Ascent...');
            tg.ready();

             // Setup initial resize and draw
             resizeCanvas(); // This now also initializes background elements

            const rawData = getQueryParam('data');
            if (!rawData) { /* ... error handling ... */ return; }

            try {
                gameData = JSON.parse(decodeURIComponent(rawData));
                console.log('Initial game data received:', gameData);

                // Update static UI elements
                balanceDisplay.innerHTML = `<span>BNB:</span> ${parseFloat(gameData.bnb_balance || 0).toFixed(8)} | <span>NIMS:</span> ${parseFloat(gameData.nims_balance || 0).toFixed(4)}`;
                jackpotDisplay.textContent = `Community Jackpot: ${parseFloat(gameData.jackpot || 0).toFixed(4)} NIMS`;
                raffleDisplay.firstChild.textContent = `Earned Tickets: ${gameData.raffle_tickets || 0} | Purchased: ${gameData.purchased_tickets || 0} `;
                updateLeaderboard();

                 // --- Game Start/Resume Logic ---
                 if (gameData.game_started && gameData.game_started.session_id) {
                     const startedInfo = gameData.game_started;
                     console.log('Game start/resume detected:', startedInfo);

                     // ... (assign sessionId, currentStake, currentToken, crashPoint as before) ...
                     sessionId = startedInfo.session_id;
                     currentStake = parseFloat(startedInfo.stake);
                     currentToken = startedInfo.token;
                     crashPoint = parseFloat(startedInfo.crash_point);

                     if (!sessionId || isNaN(currentStake) || !currentToken || isNaN(crashPoint)) {
                         throw new Error('Incomplete or invalid game_started data.');
                     }

                     // Set controls
                     stakeInput.value = currentStake.toFixed(2); tokenSelect.value = currentToken;
                     stakeInput.disabled = true; tokenSelect.disabled = true;
                     startButton.disabled = true; cashoutButton.disabled = false; restButton.disabled = true;

                     // Start the game loop
                     isGameRunning = true; hasCrashed = false;
                     currentMultiplier = 1.0; timeElapsed = 0; lastTimestamp = 0;
                     altitudePath = []; // Clear path for new game

                     if (animationFrameId) cancelAnimationFrame(animationFrameId);
                     animationFrameId = requestAnimationFrame(gameLoop);
                     console.log(`Game loop started. Session: ${sessionId}, Crash Point: ${crashPoint}`);

                 } else {
                     console.log('No active game session. Resetting to idle.');
                     resetGameVisuals(); // Ensure idle state visually
                 }

            } catch (e) { /* ... error handling, call resetGameVisuals() ... */ }

             // Final draw after initialization
             drawFrame();
        }

        // --- Start the App ---
        if (tg && tg.initData) {
             initializeApp();
        } else { /* ... Fallback/Retry logic ... */ }

    </script>
</body>
</html>
